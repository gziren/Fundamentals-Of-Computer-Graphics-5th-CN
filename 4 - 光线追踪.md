# 4 - 光线追踪

计算机图形学的基本任务之一是绘制三维物体：取一个由许多几何物体组成的场景，并计算从特定视点显示物体的二维图像。

从根本上说，渲染是一个将一组对象作为输入并产生一组像素作为输出的过程。如果输出的是矢量图像而不是光栅图像，渲染不一定要涉及像素，但我们将在本书中假设栅格图像。

考虑到每个对象对每个像素的贡献，它可以以两种一般方式组织：

```cpp
for every object:
  calculate what pix does it contribute to

for every pix:
  calculate what object does it hit, and how these object look like
```

以图像为顺序的渲染器和以对象为顺序的渲染器可以计算完全相同的图像，但是它们可以计算不同类型的效果，并且具有完全不同的性能特征。但是，从广义上讲，图像顺序渲染更容易工作，在可以产生的效果中更灵活，并且通常需要更多的执行时间来产生图像。

> 在光线追踪器中，很容易计算出准确的阴影和反射，这在对象顺序框架中是很难的。

## 4.1 基本光追算法

光线追踪器的工作原理是逐像素计算，对于每个像素，基本任务是找到在图像中该像素位置处能看到的物体。每个像素都"朝向"不同的方向，任何被像素看到的物体都必须与视线相交，视线是从视点出发、沿着该像素观察方向延伸的直线。我们要找的特定物体是与视线相交且离相机最近的那个，因为它会遮挡住其后面的任何其他物体的视野。一旦找到该物体，着色计算就会使用交点、表面法向量以及其他信息（取决于所需的渲染类型）来确定像素的颜色。
光追算法简述：

1. 生成光线，根据摄像机的几何信息计算每个像素的视线的起点和方向；
2. 光线求交，根据视线找到与其相交的最近物体；
3. 着色，根据光线求交的结果计算像素的颜色。

![Figure 4.1](pic/Pasted%20image%2020240229204518.png)

> 找到被光线击中的第一个物体及其表面法向量 $\vec{n}$
将像素颜色设置为根据击中点、光源和 $\vec{n}$ 计算得出的值

## 4.2 透视

用二维绘画或绘图来表现三维物体或场景的问题，在计算机出现之前的数百年里就已经被艺术家们研究过了。照片同样用二维图像来表现三维场景。虽然有许多非传统的成像方式，从立体主义绘画到鱼眼镜头（图4.2）再到周边摄像头，但艺术、摄影以及计算机图形学的标准方法都是线性透视，其中三维物体被投影到图像平面上，使得场景中的直线在图像中仍保持为直线。

最简单的投影类型是平行投影，其中三维点通过沿着投影方向移动直到撞击图像平面的方式映射为二维点（图4.3-4.4）。所产生的视图由投影方向和图像平面的选择决定。如果图像平面垂直于观察方向，则投影称为**正交投影**；否则，称为**斜投影**。

平行投影常用于机械和建筑图纸，因为它们保持平行线的平行性，并且保持与图像平面平行的平面物体的尺寸和形状。

![Figure 4.3](pic/Pasted%20image%2020240229205241.png)

平行投影的优点同时也是它的局限性。在我们的日常经验中（在照片中更是如此），物体随着距离的增加看起来会变小，因此，向远处延伸的平行线看起来并不平行。这是因为眼睛和照相机并不从单一的观察方向收集光线；它们收集通过特定视点的光线。正如文艺复兴时期以来艺术家们所认识到的，我们可以使用**透视投影**来产生自然逼真的视图：我们只需沿着通过单一点（即视点）的直线进行投影，而不是沿着平行线投影（图4.4）。这样，距离视点较远的物体在投影时自然会变小。透视视图由视点（而非投影方向）和图像平面的选择决定。与平行视图一样，透视视图也有斜视图和非斜视图；这种区别是基于图像中心的投影方向来划分的。

![Figure 4.4](pic/Pasted%20image%2020240229205928.png)

你可能已经学过**三点透视**的艺术规约，这是一种手工构建透视视图的系统（图4.5）。关于透视的一个令人惊讶的事实是，如果我们遵循透视背后的简单数学规则，所有透视绘画的规则都会自动得到遵循：物体直接向眼睛投影，并在它们与眼前的视平面相交的地方进行绘制。

## 4.3 计算视图光线

从前面章节可知，光线生成的基本工具是视点（或对于平行视图来说是视线方向）和图像平面。有许多方法可以确定相机几何的细节；在本节中，我们解释一种基于标准正交基的方法，它支持正常和倾斜的平行投影以及正交投影视图。

![Figure 4.5](pic/Pasted%20image%2020240229210346.png)

为了生成光线，我们首先需要光线的数学表示。光线实际上就是一个原点和一个传播方向；三维参数直线非常适合这个目的。如第2.7.7节所讨论的，从眼点 $\vec{e}$ 穿过图像平面上点 $\vec{s}$ 的三维参数直线（图4.6）由以下公式给出：

$$\vec{p}(t) = \vec{e} + t(\vec{s} - \vec{e})$$

![Figure 4.6](pic/Pasted%20image%2020240229211752.png)

这可以理解为，"我们从 $\vec{e}$ 出发，沿着向量 $(\vec{s} - \vec{e})$ 移动分数距离 $t$ 来找到点 $\vec{p}$。"因此，给定 $t$，我们可以确定一个点 $\vec{p}$。点 $\vec{e}$ 是光线的原点，$\vec{s} - \vec{e}$ 是光线的方向。

注意 $\vec{p}(0) = \vec{e}$，$\vec{p}(1) = \vec{s}$，更一般地，如果 $0 < t_1 < t_2$，那么 $\vec{p}(t_1)$ 比 $\vec{p}(t_2)$ 更靠近眼点。此外，如果 $t < 0$，那么 $\vec{p}(t)$ 在眼点的"后面"。当我们搜索被光线击中的最近物体且该物体不在眼点后面时，这些事实将很有用。

在代码中，光线通常使用某种结构或对象来表示，该结构或对象存储位置和方向。例如，在面向对象的程序中，我们可能会写：

**class** Ray
  Vec3 $\vec{o}$     // 光线原点
  Vec3 $\vec{d}$     // 光线方向
  Vec3 evaluate(real $t$)  // 计算光线上的点
  return $\vec{o}$ + ${t}\vec{d}$

为了计算视线光线，我们需要知道 $\vec{e}$（已给定）和 $\vec{s}$。寻找 $\vec{s}$ 可能看起来困难，但如果我们在正确的坐标系中看待这个问题，实际上是很直接的。

![Figure 4.7](pic/Figure%204.7.png)

我们所有的光线生成方法都从一个称为相机坐标系（图4.7）的标准正交坐标框架开始，我们用 $\vec{e}$ 表示眼点或视点，用 $\vec{u}$、$\vec{v}$ 和 $\vec{w}$ 表示三个基向量。其中 $\vec{u}$ 指向右方（从相机的视角），$\vec{v}$ 指向上方，$\vec{w}$ 指向后方，使得 $\{\vec{u}, \vec{v}, \vec{w}\}$ 形成一个右手坐标系。构建相机坐标系最常见的方法是从视点开始（它成为 $\vec{e}$），视线方向（即 $-\vec{w}$），以及上向量，然后使用第2.4.7节中描述的从两个向量构建标准正交基的过程，构建一个使 $\vec{v}$ 和 $\vec{w}$ 位于由视线方向和上方向定义的平面内的基（图4.8）。

![Figure 4.8](pic/Pasted%20image%2020240229212736.png)

### 4.3.1 正交视图

对于正交视图，所有光线都具有方向 $-\vec{w}$。尽管平行视图本身没有视点，我们仍然可以使用相机坐标系的原点来定义光线开始的平面，这样物体就可能位于相机后面。

视线光线应该从由点 $\vec{e}$ 和向量 $\vec{u}$、$\vec{v}$ 定义的平面开始；剩下需要的信息就是图像在平面上的位置。我们用四个数字来定义图像尺寸，分别对应图像的四条边：$l$ 和 $r$ 是图像左边缘和右边缘的位置，从 $\vec{e}$ 沿 $\vec{u}$ 方向测量；$b$ 和 $t$ 是图像底边缘和顶边缘的位置，从 $\vec{e}$ 沿 $\vec{v}$ 方向测量。通常，$l < 0 < r$ 且 $b < 0 < t$。（见图4.9a。）

![Figure 4.9](pic/Pasted%20image%2020240229213450.png)

在第3.2节中，我们讨论了图像中的像素坐标。为了将一个 $n_x \times n_y$ 像素的图像放入大小为 $(r - l) \times (t - b)$ 的矩形中，像素在水平方向上的间距为 $(r - l)/n_x$，在垂直方向上的间距为 $(t - b)/n_y$，边缘周围留有半个像素的空间，以便将像素网格居中放置在图像矩形内。

这意味着光栅图像中位置为 $(i, j)$ 的像素具有以下位置，公式（4.1）：

$$u = l+ \frac{r-l}{n_x}(i+0.5)$$
$$v = b+ \frac{t-b}{n_y}(j+0.5)$$

其中 $(u,v)$ 是像素在图像平面上位置的坐标，相对于原点 $\vec{e}$ 和基 $\{\vec{u}, \vec{v}\}$ 测量。

在正交视图中，我们可以简单地使用像素的图像平面位置作为光线的起始点，而且我们已经知道光线的方向就是视线方向。生成正交视线光线的步骤如下：

使用公式 (4.1) 计算 $u$ 和 $v$

$\text{ray.o} \leftarrow \vec{e} + u\vec{u} + v\vec{v}$

$\text{ray.d} \leftarrow -\vec{w}$

制作倾斜平行视图非常简单：只需允许图像平面法向量 $\vec{w}$ 与视线方向 $\vec{d}$ 分别指定。步骤完全相同，只是用 $\vec{d}$ 替代 $-\vec{w}$。当然，$\vec{w}$ 仍然用于构建 $\vec{u}$ 和 $\vec{v}$。

### 4.3.2 透视视图

对于透视视图，所有光线都有相同的原点，即视点；每个像素的不同之处在于光线方向。图像平面不再位于 $\vec{e}$ 处，而是在 $\vec{e}$ 前方某个距离 $d$ 的位置；这个距离就是图像平面距离，通常被称为焦距，因为选择 $d$ 在此处的作用与在真实相机中选择焦距的作用相同。每条光线的方向由视点和像素在图像平面上的位置确定。这种情况如图4.9所示，相应的步骤与正交投影类似：

使用公式 (4.1) 计算 $u$ 和 $v$

$\text{ray.o} \leftarrow \vec{e}$

$\text{ray.d} \leftarrow -d\vec{w} + u\vec{u} + v\vec{v}$

与平行投影一样，可以通过将图像平面法向量与投影方向分别指定来实现倾斜透视视图。

## 4.4 光线与物体的交点

一旦我们生成了光线 $\vec{e} + t\vec{d}$，接下来需要找到与任何物体的第一个交点，其中 $t > 0$。在实践中，解决一个稍微更通用的问题是有用的：找到光线与表面在区间 $[t_0, t_1]$ 内参数 $t$ 处的第一个交点。基本的光线相交问题就是 $t_0 = 0$ 和 $t_1 = +\infty$ 的情况。我们将针对球体和三角形来解决这个问题。在下一节中，将讨论多个物体的情况。

### 4.4.1 光线与球面求交

给定光线 $\vec{p}(t) = \vec{e} + t\vec{d}$ 和隐式曲面 $f(\vec{p}) = 0$（参见第2.7.3节），我们想知道它们在哪里相交。交点发生在光线上的点满足隐式方程时，所以我们要求解的 $t$ 值是满足以下方程的值：

$$f(\vec{p}(t)) = 0 \quad \text{或} \quad f(\vec{e} + t\vec{d}) = 0$$

中心为 $\vec{c} = (x_c, y_c, z_c)$、半径为 $R$ 的球体可以用隐式方程表示为：

$$(x - x_c)^2 + (y - y_c)^2 + (z - z_c)^2 - R^2 = 0$$

我们可以用向量形式写出同样的方程：

$$(\vec{p} - \vec{c}) \cdot (\vec{p} - \vec{c}) - R^2 = 0$$

任何满足这个方程的点 $\vec{p}$ 都在球面上。如果我们将光线上的点 $\vec{p}(t) = \vec{e} + t\vec{d}$ 代入这个方程，我们得到一个关于 $t$ 的方程，该方程由那些产生球面上点的 $t$ 值满足：

$$(\vec{e} + t\vec{d} - \vec{c}) \cdot (\vec{e} + t\vec{d} - \vec{c}) - R^2 = 0$$

重新整理项可得：

$$(\vec{d} \cdot \vec{d})t^2 + 2\vec{d} \cdot (\vec{e} - \vec{c})t + (\vec{e} - \vec{c}) \cdot (\vec{e} - \vec{c}) - R^2 = 0$$

这里，除了参数 $t$ 之外，所有项都是已知的，所以这是一个关于 $t$ 的经典二次方程，意味着它具有以下形式：

$$At^2 + Bt + C = 0$$

这个方程的解在第2.2节中讨论。二次方程解中平方根号下的项 $B^2 - 4AC$ 称为判别式，它告诉我们有多少个实数解。如果判别式为负数，其平方根是虚数，直线和球体不相交。如果判别式为正数，有两个解：一个解对应光线进入球体的位置，另一个对应光线离开球体的位置。如果判别式为零，光线与球体相切，恰好在一个点接触。将球体的实际项代入并约去因子2，我们得到：

$$t = \frac{-\vec{d} \cdot (\vec{e} - \vec{c}) \pm \sqrt{(\vec{d} \cdot (\vec{e} - \vec{c}))^2 - (\vec{d} \cdot \vec{d})((\vec{e} - \vec{c}) \cdot (\vec{e} - \vec{c}) - R^2)}}{(\vec{d} \cdot \vec{d})}$$

其中：

- $\vec{e}$ 是光线起点
- $\vec{d}$ 是光线方向向量
- $\vec{c}$ 是球心
- $R$ 是球体半径

判别式为：
$$\Delta = (\vec{d} \cdot (\vec{e} - \vec{c}))^2 - (\vec{d} \cdot \vec{d})((\vec{e} - \vec{c}) \cdot (\vec{e} - \vec{c}) - R^2)$$

- 当 $\Delta < 0$ 时：无交点
- 当 $\Delta = 0$ 时：相切，一个交点
- 当 $\Delta > 0$ 时：相交，两个交点（$t_1$ 和 $t_2$，分别对应进入和离开球体的位置）

这个公式是光线追踪中球体求交的标准算法基础。

在实际实现中，你应该首先检查判别式的值，然后再计算其他项。为了正确找到区间 $[t_0, t_1]$ 内最近的交点，有三种情况：如果两个解中较小的那个在区间内，它就是第一个击中点；否则，如果较大的解在区间内，它就是第一个击中点；否则，没有击中。

如第2.7.4节所述，点 $\vec{p}$ 处的法向量由梯度给出：$\vec{n} = 2(\vec{p} - \vec{c})$。单位法向量为 $\frac{\vec{p} - \vec{c}}{R}$。

### 4.4.2 光线与三角形求交

为了计算光线与参数曲面的相交，我们建立一个方程组，使得笛卡尔坐标都匹配：

$$
\begin{cases}
x_e + t x_d = f(u,v) \\
y_e + t y_d = g(u,v) \\
z_e + t z_d = h(u,v)
\end{cases}
$$

或者

$$\vec{e} + t\vec{d} = \vec{f}(u,v)$$

- $(x_e, y_e, z_e)$ 是光线起点 $\vec{e}$ 的坐标分量
- $(x_d, y_d, z_d)$ 是光线方向向量 $\vec{d}$ 的坐标分量
- $f(u,v), g(u,v), h(u,v)$ 分别是参数曲面在 $x, y, z$ 方向上的参数方程
- $\vec{f}(u,v) = (f(u,v), g(u,v), h(u,v))$ 是参数曲面的向量参数方程
- $t$ 是光线参数
- $(u,v)$ 是曲面参数

在这里，我们有三个方程和三个未知数（$t$、$u$ 和 $v$）。在曲面是参数平面的情况下，参数方程是线性的，可以用向量形式表示，如第2.9.2节所述。如果三角形的顶点是 $\vec{a}$、$\vec{b}$ 和 $\vec{c}$，那么当满足以下条件时会发生相交：

$$\vec{e} + t\vec{d} = \vec{a} + \beta(\vec{b} - \vec{a}) + \gamma(\vec{c} - \vec{a}) \quad (4.2)$$

对于某些 $t$、$\beta$ 和 $\gamma$。求解这个方程可以同时告诉我们：

- $t$：定位光线上交点的位置
- $(\beta, \gamma)$：定位交点相对于三角形的位置

交点 $\vec{p}$ 将位于 $\vec{e} + t\vec{d}$，如图4.10所示。

再次根据第2.9.2节的内容，我们知道当且仅当 $\beta > 0$、$\gamma > 0$ 且 $\beta + \gamma < 1$ 时，交点在三角形内部。否则，光线击中了三角形外的平面，因此未击中三角形。

如果没有解，要么三角形是退化的，要么光线与包含三角形的平面平行。

为了求解方程(4.2)中的 $t$、$\beta$ 和 $\gamma$，我们将其从向量形式展开为三个坐标的三个方程：

**公式推导：**

将向量方程：
$$\vec{e} + t\vec{d} = \vec{a} + \beta(\vec{b} - \vec{a}) + \gamma(\vec{c} - \vec{a})$$

展开为分量形式，得到：

**x坐标方程：**
$$e_x + tx_d = a_x + \beta(b_x - a_x) + \gamma(c_x - a_x)$$

**y坐标方程：**
$$e_y + ty_d = a_y + \beta(b_y - a_y) + \gamma(c_y - a_y)$$

**z坐标方程：**
$$e_z + tz_d = a_z + \beta(b_z - a_z) + \gamma(c_z - a_z)$$

重新整理为标准线性方程组形式：

$$\begin{cases}
tx_d - \beta(b_x - a_x) - \gamma(c_x - a_x) = a_x - e_x \\
ty_d - \beta(b_y - a_y) - \gamma(c_y - a_y) = a_y - e_y \\
tz_d - \beta(b_z - a_z) - \gamma(c_z - a_z) = a_z - e_z
\end{cases}$$

这是一个关于 $(t, \beta, \gamma)$ 的3×3线性方程组，可以使用矩阵方法（如克拉默法则）或高斯消元法求解。

可以将上式改造成线性方程组：
$$\begin{bmatrix} x_a-x_b&&x_a-x_c&&x_d\\y_a-y_b&&y_a-y_c&&y_d\\z_a-z_b&&z_a-z_c&&z_d \end{bmatrix}\begin{bmatrix} \beta \\ \gamma \\ t \end{bmatrix}=\begin{bmatrix} x_a-x_e\\y_a-y_e\\z_a-z_e \end{bmatrix}$$

最快求解 3 阶线性方程组的经典方法是克莱默法则：这里不细讲。它可以化简出一步完成的计算式。

![Cramer's Rule](pic/Pasted%20image%2020240301105208.png)

上式中有很多重复的结构，如$ei-hf$，我们可以重复使用这些数据来减少算数运算的次数。
最后是关于交点在三角形内的判定：

![raytri](pic/Pasted%20image%2020240301110239.png)

### 4.4.3 软件中的光线求交

在光线追踪程序中，采用面向对象的设计是一个好想法，可以创建一个名为 Surface 的类，并派生出 Triangle、Sphere 等子类。任何光线可以相交的对象，包括表面组合或效率结构（第12.3节），都应该是 Surface 的子类。光线追踪程序将对整个模型只持有一个 Surface 引用，这样可以透明地添加新类型的对象和效率结构。

Surface 类的核心接口是一个与光线相交的方法（Kirk & Arvo, 1988）：

```cpp
class Surface
{
    HitRecord hit(Ray r, real t0, real t1);
};
```

这里，`(t0, t1)` 是光线上返回碰撞检测的区间，`HitRecord` 是一个包含表面相交所需所有数据的类：

```cpp
class HitRecord
{
    Surface s;  // 被击中的表面
    real t;     // 击中点沿光线的坐标
    Vec3 n;     // 击中点处的表面法向量
};
```

被击中的表面、$t$ 值和表面法向量是最基本的必需信息，但也可以存储其他数据，如纹理坐标或切向量。根据编程语言的不同，击中记录可能不是直接从函数返回，而是通过引用传递并填充数据。未击中可以通过设置 $t = \infty$ 的击中记录来表示。

**扩展的 HitRecord 设计：**

```cpp
class HitRecord
{
    Surface* surface;      // 被击中的表面
    real t;               // 击中点沿光线的参数
    Vec3 normal;          // 表面法向量
    Vec2 texCoords;       // 纹理坐标 (u, v)
    Vec3 tangent;         // 切向量
    Vec3 bitangent;       // 副切向量
    bool frontFace;       // 是否为正面击中
  
    // 构造函数初始化为未击中状态
    HitRecord() : t(INFINITY) {}
};
```

**不同语言的实现方式：**

**C++ 引用传递版本：**
```cpp
bool hit(const Ray& r, real t0, real t1, HitRecord& record);
```

**返回值版本：**
```cpp
HitRecord hit(const Ray& r, real t0, real t1);
```

**击中检测逻辑：**
```cpp
// 检查是否击中
if (record.t != INFINITY && record.t >= t0 && record.t <= t1) {
    // 有效击中
    Vec3 hitPoint = r.origin + record.t * r.direction;
    // 进行光照计算...
} else {
    // 未击中，返回背景色
}
```

### 4.4.4 光线与一组物体求交

当然，大多数有趣的场景由多个对象组成，当我们将光线与场景相交时，我们必须只找到沿着光线与相机最近的交叉点。
实现这一点的一个简单方法是将一组对象本身视为另一种类型的对象。要使光线与组相交，只需使光线与组中的对象相交并返回具有最小 t 值的交点。

```cpp
class Group:Surface{
  list-of-Surface surfaces
  HitRecord hit(Ray ray, real t0, real t1);
}

HitRecord hit(Ray ray, real t0, real t1){
  HitRecord closet-hit(inf) //initiate result with no-hit
  for s in surfaces do
    rec = s.hit(ray, t0, t1)
    if rec.t < inf then
      cloest-hit = rec
      t1 = t //continually reduce the range of intersection
  return cloest-hit
}
```

注意到`t1 = t`这句话可以不断地缩小求交的范围。所以新的击中目标一定是更近的。

一旦光线-场景求交可行，我们就可以渲染图像，但是更好的结果取决于包含更多的视觉线索。

### 4.4.4 光线与一组物体相交

当然，大多数有趣的场景都包含多个物体，当我们让光线与场景相交时，必须只找到沿光线方向距离相机最近的交点。实现这一点的简单方法是将一组物体本身视为另一种类型的物体。要让光线与一个组相交，只需让光线与组中的各个物体相交，并返回具有最小 $t$ 值的交点。以下代码在区间 $t \in [t_0, t_1]$ 中测试击中：

```cpp
class Group : public Surface
{
    list<Surface*> surfaces;  // 组中所有表面的列表
  
    HitRecord hit(Ray ray, real t0, real t1)
    {
        HitRecord closest_hit;     // 初始化为未击中状态 (t = ∞)

        for (Surface* surf : surfaces) {
            HitRecord rec = surf->hit(ray, t0, t1);
            if (rec.t < INFINITY) {
                closest_hit = rec;
                t1 = rec.t;        // 缩小搜索区间
            }
        }
        return closest_hit;
    }
};
```

**算法要点分析：**

1. **区间缩减优化**：代码通过缩小交点区间 $[t_0, t_1]$ 来优化性能，使得对 `surf.hit` 的调用只会击中比当前最近交点更近的表面。

2. **递归结构**：Group 类作为 Surface 的子类，可以包含其他 Group，形成层次化的场景结构。

3. **最近交点查找**：通过比较 $t$ 值确保返回的是最近的有效交点。

**优化版本：**
```cpp
HitRecord hit(Ray ray, real t0, real t1)
{
    HitRecord closest_hit;
    real closest_t = t1;
  
    for (Surface* surf : surfaces) {
        HitRecord rec = surf->hit(ray, t0, closest_t);
        if (rec.t < closest_t) {
            closest_hit = rec;
            closest_t = rec.t;  // 持续缩小搜索范围
        }
    }
    return closest_hit;
}
```

一旦光线-场景相交功能正常工作，我们就可以渲染出如图4.11所示的图像，但更好的结果需要包含更多的视觉线索，正如我们接下来要描述的那样。

## 4.5 着色 Shading

一旦确定了像素的可见表面，就通过评估着色模型来计算像素值。具体如何实现完全取决于应用需求——方法范围从简单的启发式算法到复杂的基于物理的模型。完全相同的着色模型既可以用于光线追踪，也可以用于基于物体顺序的渲染方法。

第5章描述了一个适用于基础光线追踪器的简单着色模型，这也是我们用来制作本章渲染图像的模型。为了获得更真实的效果，你可以升级到第14章讨论的模型，这些模型在物理上更接近真实表面的特性。在这里，我们将讨论光线追踪器如何计算着色的输入参数。

**着色计算的核心流程：**

```cpp
Vec3 shade(const HitRecord& hit, const Ray& ray, const Scene& scene)
{
    // 1. 获取表面材质属性
    Material mat = hit.surface->getMaterial(hit.texCoords);
  
    // 2. 计算几何信息
    Vec3 hitPoint = ray.origin + hit.t * ray.direction;
    Vec3 normal = hit.normal;
    Vec3 viewDir = -normalize(ray.direction);
  
    // 3. 光照计算
    Vec3 color = computeLighting(hitPoint, normal, viewDir, mat, scene);
  
    return color;
}
```

**着色输入参数的计算：**

1. **交点位置**：$\mathbf{p} = \mathbf{o} + t\mathbf{d}$
2. **表面法向量**：从 HitRecord 获取或重新计算
3. **视线方向**：$\mathbf{v} = -\hat{\mathbf{d}}$（光线方向的反向）
4. **材质属性**：漫反射系数、镜面反射系数、粗糙度等
5. **纹理坐标**：用于纹理查找和程序化材质

**光线追踪的优势：**
- **精确可见性**：准确计算哪些光源可以到达表面点
- **全局光照**：自然支持反射、折射和阴影
- **材质一致性**：相同的着色模型可以无缝集成

无论选择简单的Phong模型还是复杂的PBR（基于物理的渲染）模型，光线追踪器都能提供准确的几何和可见性信息作为着色计算的基础。

### 4.5.1 光源

为了支持着色计算，光线追踪程序总是包含一个光源列表。对于第5章的着色模型，我们需要三种类型的光源：**点光源**（从空间中的一点发射光线）、**方向光源**（从单一方向照亮场景）和**环境光源**（提供恒定照明以填补阴影）。在更高级的系统中，还支持其他类型的光源，如**面光源**（基本上是发光的场景几何体）或**环境光源**（使用图像表示来自远处光源如天空的光照）。

从点光源或方向光源计算着色需要特定的几何信息，在光线追踪器中，当确定视线光线击中表面后，我们拥有确定以下四个向量所需的全部信息：

• **着色点** $\mathbf{x}$ 可以通过在交点的 $t$ 值处计算视线光线来获得。
• **表面法向量** $\mathbf{n}$ 取决于表面类型（球面、三角形等），每个表面都需要能够计算光线与其相交点处的法向量。
• **光照方向** $\mathbf{l}$ 根据光源位置或方向作为着色计算的一部分来计算。
• **视线方向** $\mathbf{v}$ 简单地是视线光线方向的反向（$\mathbf{v} = -\mathbf{d}/\|\mathbf{d}\|$）。

环境光源的着色计算要简单得多：没有 $\mathbf{l}$ 向量，因为光线来自四面八方；着色不依赖于 $\mathbf{v}$；对于第5章的简单模型，甚至不依赖于 $\mathbf{x}$ 或 $\mathbf{n}$。

在包含多个光源的场景中计算着色，只需简单地累加各光源的贡献。在基础光线追踪器中，你可以简单地遍历所有光源，计算每个光源的着色贡献，并将结果累积到像素颜色中。

### 4.5.2 软件中的着色

光线追踪程序通常包含表示光源和材质的对象。光源可以是Light类子类的实例，它们必须包含足够的信息来完全描述光源。由于着色还需要描述表面材质的参数，另一个有用的类是Material，它封装了评估着色模型所需的一切信息。

不同的系统采用不同的方法来在光源和材质之间划分着色计算。与本章介绍相符的一种方法是让光源负责整体照明计算，让材质负责计算BRDF值：

```cpp
class Light{
  Color illuminate(Ray ray, HitRecord hrec)
}
class Material{
  Color evaluate(Vec3 l, Vec3 v, Vec3 n)
}
```

> BRDF是**双向反射分布函数**（Bidirectional Reflectance Distribution Function）的缩写。
> BRDF是计算机图形学中描述表面如何反射光线的数学函数。具体来说：
> BRDF函数 $f_r(\omega_i, \omega_o)$ 描述了当光线从方向 $\omega_i$ 入射到表面上时，有多少光线会沿着方向 $\omega_o$ 反射出去。
>
> - **输入**：入射光方向和出射光方向（都相对于表面法向量）
> - **输出**：反射光与入射光的比值
> - **单位**：通常是 $sr^{-1}$（每球面度）
>
> 1. **Lambert漫反射BRDF**：
>    `f_r = ρ/π`
>    其中ρ是反照率，π是归一化因子
> 2. **Phong镜面反射BRDF**：
>    `f_r = (n+2)/(2π) * (R·V)^n`
>    其中n是光泽度指数
> 3. **Cook-Torrance微表面BRDF**：
>    `f_r = DFG/(4(N·L)(N·V))`
>    包含分布项D、菲涅尔项F和几何项G
>
> BRDF允许我们：
>
> - 精确模拟不同材质的光学特性
> - 实现物理真实的渲染
> - 支持复杂的材质如金属、塑料、皮肤等
>
> BRDF是现代基于物理渲染（PBR）的核心概念。
>

每个 surface 存储对自身材质的引用，故一个点光源类可以写成：

```cpp
// cpp伪代码
class PointLight: Light {
  Color I;
  Vec3 p;
  
  Color illuminate(Ray ray, HitRecord hrec){
    Vec3 x = ray.evaluate(hrec.t); // 计算交点位置
    real r = ||p-x||; // 计算光源距离
    Vec3 l = (p-x)/r; // 计算光照方向（从交点指向光源的单位向量）
    Vec3 n = hrec.normal; // 获取表面法向量
    Color E = max(0, dot(n, l))*I/r^2;  // Lambert漫反射，这里的r^2是光线衰减和距离平方呈反比
    Color k = hrec.surface.material.evaluate(l, v, n); // BRDF计算，表示材质如何反射光线，v 应该是视线方向向量（从交点指向相机）
    return kE; // 材质响应*光照强度
  }
}
```

这些计算假设Color类包含颜色的RGB分量并支持分量逐个相乘。这种安排也适合将环境光作为光源来处理，方法是将环境光系数作为材质的属性：

```cpp
// 环境光类，继承自Light基类
class AmbientLight, subclass of Light
    // 环境光强度（颜色）
    Color Ia
  
    // 计算环境光对指定交点的光照贡献
    Color illuminate(Ray ray, HitRecord hrec)
        // 从命中表面的材质中获取环境光反射系数
        Color ka = hrec.surface.material.ka

        // 返回环境光贡献：环境光系数 × 环境光强度
        return ka * Ia
```

包含交点计算和多光源处理的完整光线着色计算可以是这样的：

```cpp
function shade-ray (Ray ray, real t0, real t1)
    // 计算光线与场景中所有物体的交点，返回最近的命中记录
    HitRecord rec = scene.hit(ray, t0, t1)

    // 检查是否找到有效交点（t值小于无穷大表示有交点）
    if rec.t < ∞ then
        // 初始化累积颜色为黑色
        Color c = (0,0,0)

        // 遍历场景中的所有光源
        for light in scene.lights do
            // 计算当前光源对该交点的光照贡献并累加
            c = c + light.illuminate(ray, rec)

        // 返回所有光源贡献的总和
        return c
    else
        // 光线未命中任何物体，返回背景色
        return background-color

```

这种设置保持了材质和光源的合理分离，并允许你后续透明地添加新类型的材质和光源。纹理为光线追踪器的架构增加了一些复杂性；详见第11.2.5节。

着色本身使3D物体的图像更加真实和易于理解，但它并不能显示物体与其他物体之间的相互作用。例如，图4.12中的球体看起来像是漂浮在它们所依靠的地面之上。

### 4.5.3 阴影

一旦在光线追踪器中实现了基本的着色，阴影对于点光源和方向光源可以非常容易地添加。如果我们想象自己在表面上某一点 $\mathbf{x}$ 处，点 $\mathbf{x}$ 处于阴影中当且仅当我们朝着光源的方向“看”时，看到一个物体位于我们与光源之间。如果两者之间没有物体，那么光线不会被阻挡。

这可以通过图4.13表示，其中光线 $\mathbf{x} + t_l$ 没有碰到任何物体，因此点 $\mathbf{x}$ 没有处于阴影中。另一方面，点 $\mathbf{x'}$ 处于阴影中，因为光线 $\mathbf{x'} + t_{l'}$ 碰到了物体。确定是否处于阴影中的光线称为阴影光线，以此区别于视线光线。

为了得到着色算法，我们在添加来自光源的着色计算时，增加一个条件语句以判断光线是否被阴影遮蔽。在一个简单的实现中，阴影光线检查 $t \in [0, r]$，但由于数值误差，这可能导致与点 $p$ 所在的表面发生交点。为了避免这个问题，通常的做法是测试 $t \in (e, r]$，其中 $e$ 是一个非常小的正数（如图4.14所示）。

可以通过追踪阴影光线并增加条件语句，将阴影测试添加到上面提到的 `PointLight illuminate` 方法中：

```cpp
// 追踪阴影光线并检查是否有物体遮挡
HitRecord srec = scene.hit(Ray(x, l), e, r) // 计算从点x出发的阴影光线与场景的交点

if (srec.t < ∞) {
    // 如果与场景中物体相交，点处于阴影中
    proceed with normal illumination calculation // 继续正常的光照计算
} else {
    return 0 // 点处于阴影中，返回0，表示没有光照
}
```

方向光源的阴影测试类似，但使用 $t_1 = \infty$ 而不是 $r$。

需要注意的是，每个光源的光照计算都需要一条单独的阴影光线，而在计算环境光着色时不需要进行阴影测试。

阴影在显示邻近物体之间的关系方面起着重要的视觉作用，如图4.15所示。

### 4.5.4 镜面反射

![镜面反射](pic/Pasted%20image%2020240301200512.png)

在光线追踪程序中添加理想镜面反射是很直观的。关键观察如图4.16所示，从方向**e**观察的观察者会看到从表面向方向**r**看到的内容。向量**r**是向量**-d**关于表面法向量**n**的反射，可以使用**d**在表面法向量方向上的投影来计算(4.3)：

$$\mathbf{r} = \mathbf{d} - 2(\mathbf{d} \cdot \mathbf{n})\mathbf{n}$$

在现实世界中，当光线从表面反射时会损失一些能量，这种损失对于不同颜色可能是不同的。例如，金属反射黄光比蓝光更高效，因此它会改变所反射物体的颜色。这可以通过在shade-ray中添加递归调用来实现，在计算完所有光源后再添加一项贡献：

```cpp
// 添加镜面反射贡献
color c = c + km * shade-ray(Ray(p, r), ε, ∞)
```

其中$k_m$（表示"镜面反射"）是镜面反射的RGB颜色系数。我们需要确保传递$t_0 = ε$，原因与阴影光线相同；我们不希望反射光线撞击产生它的物体。

上述递归调用的问题是它可能永远不会终止。例如，如果光线从房间内部开始，它将永远反弹下去。这可以通过添加最大递归深度来解决。如果只有在$k_m$不为零时才生成反射光线，代码会更加高效。

使用常数镜面反射系数$k_m$会产生简单光线追踪器特有的外观效果（图4.17）；在现实世界中，这个系数会根据入射角度发生显著变化。关于更好的模型，请参见第14章。

## 5. 笔记

### 5.1 常见问题

**• 为什么光线追踪中没有透视矩阵？**

z缓冲区中的透视矩阵存在是为了让我们能够将透视投影转换为平行投影。在光线追踪中这是不需要的，因为通过从视点发散光线可以很容易地隐式实现透视投影。

**• 光线追踪能够实现交互式渲染吗？**

对于足够小的模型和图像，任何现代PC都有足够的计算能力实现交互式光线追踪。在实际应用中，全屏实现需要多个CPU配合共享帧缓冲区。计算机性能的增长速度远快于屏幕分辨率的提升，因此传统PC能够在屏幕分辨率下对复杂场景进行光线追踪只是时间问题。

**• 光线追踪在硬件图形程序中有用吗？**

光线追踪经常用于拾取操作。当用户在3D图形程序中点击某个像素时，程序需要确定该像素内可见的是哪个物体。光线追踪是确定这一点的理想方法。

### 5.2 练习

#### 5.2.1 问题1

光线 $(1,1,1) + t(-1,-1,-1)$ 与以原点为中心、半径为1的球体的交点的光线参数是什么？注意：这是一个很好的调试案例。

##### 解答

为了求解光线与球体的交点，我需要将光线方程代入球面方程。

**给定条件：**
- 光线：$\mathbf{o} + t\mathbf{d} = (1,1,1) + t(-1,-1,-1)$
- 球面：$x^2 + y^2 + z^2 = 1$（以原点为中心，半径为1）

**求解过程：**

将光线方程的各分量表示为：
- $x = 1 - t$
- $y = 1 - t$
- $z = 1 - t$

代入球面方程：
$(1-t)^2 + (1-t)^2 + (1-t)^2 = 1$

展开：
$3(1-t)^2 = 1$

$(1-t)^2 = \frac{1}{3}$

$1-t = \pm\frac{1}{\sqrt{3}}$

因此：
$t = 1 \mp \frac{1}{\sqrt{3}}$

**交点的光线参数为：**
- $t_1 = 1 - \frac{1}{\sqrt{3}} = 1 - \frac{\sqrt{3}}{3} \approx 0.423$
- $t_2 = 1 + \frac{1}{\sqrt{3}} = 1 + \frac{\sqrt{3}}{3} \approx 1.577$

**为什么这是个好的调试案例：**
这个案例有几个特点使其成为理想的调试用例：
1. 光线起点$(1,1,1)$在球外
2. 光线方向$(-1,-1,-1)$指向原点
3. 计算结果简洁，容易验证
4. 两个交点都在正的$t$值处，符合物理意义

#### 5.2.2 问题2

光线 $(1,1,1) + t(-1,-1,-1)$ 与顶点为 $(1,0,0)$、$(0,1,0)$ 和 $(0,0,1)$ 的三角形相交时的重心坐标和光线参数是什么？注意：这是一个很好的调试案例。

##### 解答：使用Möller-Trumbore算法

**给定条件：**
- 光线：$\mathbf{O} + t\mathbf{D} = (1,1,1) + t(-1,-1,-1)$
- 三角形顶点：$\mathbf{V_0} = (1,0,0)$，$\mathbf{V_1} = (0,1,0)$，$\mathbf{V_2} = (0,0,1)$

**步骤1：计算边向量**
- $\mathbf{E_1} = \mathbf{V_1} - \mathbf{V_0} = (-1,1,0)$
- $\mathbf{E_2} = \mathbf{V_2} - \mathbf{V_0} = (-1,0,1)$

**步骤2：计算向量**
- $\mathbf{P} = \mathbf{D} \times \mathbf{E_2} = (-1,-1,-1) \times (-1,0,1) = (-1,2,-1)$
- $det = \mathbf{E_1} \cdot \mathbf{P} = (-1,1,0) \cdot (-1,2,-1) = 1 + 2 + 0 = 3$

**步骤3：计算u坐标**
- $\mathbf{T} = \mathbf{O} - \mathbf{V_0} = (1,1,1) - (1,0,0) = (0,1,1)$
- $u = \frac{\mathbf{T} \cdot \mathbf{P}}{det} = \frac{(0,1,1) \cdot (-1,2,-1)}{3} = \frac{0 + 2 - 1}{3} = \frac{1}{3}$

**步骤4：计算v坐标**
- $\mathbf{Q} = \mathbf{T} \times \mathbf{E_1} = (0,1,1) \times (-1,1,0) = (-1,-1,1)$
- $v = \frac{\mathbf{D} \cdot \mathbf{Q}}{det} = \frac{(-1,-1,-1) \cdot (-1,-1,1)}{3} = \frac{1 + 1 - 1}{3} = \frac{1}{3}$

**步骤5：计算光线参数t**
- $t = \frac{\mathbf{E_2} \cdot \mathbf{Q}}{det} = \frac{(-1,0,1) \cdot (-1,-1,1)}{3} = \frac{1 + 0 + 1}{3} = \frac{2}{3}$

##### 验证

**检查重心坐标约束：**
- $u = \frac{1}{3} \geq 0$ ✓
- $v = \frac{1}{3} \geq 0$ ✓
- $u + v = \frac{2}{3} \leq 1$ ✓

**重心坐标：**
- $\alpha = 1 - u - v = 1 - \frac{1}{3} - \frac{1}{3} = \frac{1}{3}$
- $\beta = u = \frac{1}{3}$
- $\gamma = v = \frac{1}{3}$

**验证交点：**
光线上的点：$(1,1,1) + \frac{2}{3}(-1,-1,-1) = (\frac{1}{3}, \frac{1}{3}, \frac{1}{3})$

重心坐标计算的点：$\frac{1}{3}(1,0,0) + \frac{1}{3}(0,1,0) + \frac{1}{3}(0,0,1) = (\frac{1}{3}, \frac{1}{3}, \frac{1}{3})$ ✓

##### 最终答案
- **光线参数：** $t = \frac{2}{3}$
- **重心坐标：** $(\alpha, \beta, \gamma) = (\frac{1}{3}, \frac{1}{3}, \frac{1}{3})$

##### 为什么这是个好的调试案例
1. **对称性：** 重心坐标完全相等，易于验证
2. **简单数值：** 所有坐标都是简单分数
3. **几何直观：** 交点位于三角形的重心
4. **边界测试：** 可以验证算法的数值稳定性

##### Möller-Trumbore算法详解

###### 算法背景

[Möller-Trumbore算法](https://zhuanlan.zhihu.com/p/451582864)是计算机图形学中用于**光线-三角形相交测试**的经典算法，由Tomas Möller和Ben Trumbore在1997年提出。它直接计算重心坐标，避免了先计算平面交点再判断是否在三角形内的两步过程。

###### 算法原理

**核心思想：** 直接求解线性方程组，同时得到光线参数$t$和重心坐标$(u,v)$。

设三角形的三个顶点为$\mathbf{V_0}$、$\mathbf{V_1}$、$\mathbf{V_2}$，光线为$\mathbf{O} + t\mathbf{D}$。

三角形上任意一点可以用重心坐标表示：
$$\mathbf{P} = (1-u-v)\mathbf{V_0} + u\mathbf{V_1} + v\mathbf{V_2}$$

展开后：
$$\mathbf{P} = \mathbf{V_0} + u(\mathbf{V_1} - \mathbf{V_0}) + v(\mathbf{V_2} - \mathbf{V_0})$$

定义边向量：
- $\mathbf{E_1} = \mathbf{V_1} - \mathbf{V_0}$
- $\mathbf{E_2} = \mathbf{V_2} - \mathbf{V_0}$

则：$$\mathbf{P} = \mathbf{V_0} + u\mathbf{E_1} + v\mathbf{E_2}$$

###### 关键步骤解析

1. 第二步中P和det的含义

**向量P：**
$$\mathbf{P} = \mathbf{D} \times \mathbf{E_2}$$

**几何意义：**
- $\mathbf{P}$是光线方向向量$\mathbf{D}$与三角形边向量$\mathbf{E_2}$的叉积
- 它垂直于$\mathbf{D}$和$\mathbf{E_2}$构成的平面
- 用于后续计算重心坐标$u$

**行列式det：**
$$det = \mathbf{E_1} \cdot \mathbf{P} = \mathbf{E_1} \cdot (\mathbf{D} \times \mathbf{E_2})$$

**几何意义：**
- $det$是由$\mathbf{E_1}$、$\mathbf{D}$、$\mathbf{E_2}$构成的**标量三重积**
- 表示这三个向量构成的平行六面体的**有向体积**
- **关键作用：**
  - 如果$det = 0$，说明光线与三角形平行，无交点
  - $det$的符号决定了三角形的朝向（背面剔除）
  - $det$作为分母，用于归一化重心坐标

###### 数学推导核心

通过联立方程：
$$\mathbf{O} + t\mathbf{D} = \mathbf{V_0} + u\mathbf{E_1} + v\mathbf{E_2}$$

重新排列：
$$t\mathbf{D} - u\mathbf{E_1} - v\mathbf{E_2} = \mathbf{O} - \mathbf{V_0}$$

这是一个3×3的线性方程组，Möller-Trumbore算法通过巧妙的向量运算直接求解，避免了矩阵求逆的计算开销。

###### 算法优势

1. **高效性：** 一次计算同时得到$t$、$u$、$v$
2. **数值稳定：** 避免了两步法可能的数值误差累积
3. **内存友好：** 只需要临时存储几个向量
4. **易于优化：** 可以提前退出，支持背面剔除

#### 5.2.3 问题3

对"良好"（非对抗性）模型上的光线追踪进行粗略的时间复杂度计算。将你的分析分为预处理和图像计算两个阶段，以便你可以预测静态模型多帧光线追踪的行为。

##### 预处理阶段（Preprocessing Phase）

**主要任务：构建加速数据结构**

**BVH（边界体积层次结构）构建**
- **输入：** $N$ 个三角形
- **时间复杂度：** $O(N \log N)$
- **空间复杂度：** $O(N)$

**具体分析：**

```text
构建过程：
1. 排序三角形：O(N log N)
2. 递归分割：O(N) × O(log N) 层 = O(N log N)
3. 计算包围盒：O(N)

总计：O(N log N)
```

#### 其他预处理任务
- 纹理加载：$O(T)$（T为纹理大小）
- 材质参数设置：$O(M)$（M为材质数量）
- 相机参数计算：$O(1)$

**预处理总复杂度：** $O(N \log N + T + M)$

**图像计算阶段（Image Computation Phase）**

**主要参数：**
- 图像分辨率：$W \times H$
- 每像素采样数：$S$
- 平均递归深度：$D$
- 场景三角形数：$N$

**单条光线的遍历复杂度**
使用BVH加速结构：
- **理论最优：** $O(\log N)$
- **实际情况：** $O(\sqrt{N})$ 到 $O(\log N)$ 之间

**原因分析：**
```cpp
// BVH遍历的典型情况
期望遍历节点数 ≈ log₂(N) + 几何复杂度修正
实际交点测试数 ≈ √N （对于"良好"场景）
```

**完整像素计算**
每个像素需要：
- 主光线：1条
- 阴影光线：$L$条（L为光源数量）
- 反射/折射光线：递归深度$D$

**单像素复杂度：**
$$O((1 + L + D) \times \log N)$$

**总图像计算复杂度**
$$O(W \times H \times S \times (1 + L + D) \times \log N)$$

**多帧渲染分析（静态模型）**

1. 第一帧
```text
总时间 = 预处理时间 + 渲染时间
       = O(N log N) + O(W×H×S×(1+L+D)×log N)
```

2. 后续帧（相同静态场景）
```text
总时间 = 渲染时间（预处理可重用）
       = O(W×H×S×(1+L+D)×log N)
```

**实际数值估算**

**典型场景参数：**
- 分辨率：1920×1080
- 三角形数：100万
- 每像素采样：4
- 递归深度：5
- 光源数：3

**计算量估算：**
```
像素总数：2,073,600
每像素光线数：4 × (1 + 3 + 5) = 36
总光线数：≈ 75百万条
每条光线BVH遍历：log₂(10⁶) ≈ 20次节点访问
总BVH访问：≈ 15亿次
```

**复杂度总结表**

| 阶段   | 一次性成本    | 每帧成本            | 主导因子     |
| ------ | ------------- | ------------------- | ------------ |
| 预处理 | $O(N \log N)$ | $O(1)$              | 场景复杂度   |
| 渲染   | -             | $O(W×H×S×D×\log N)$ | 图像质量设置 |

**性能优化策略**

1. **预处理优化：**
   - 使用SBVH（Spatial BVH）
   - 并行构建加速结构

2. **渲染优化：**
   - 自适应采样
   - 重要性采样
   - GPU并行化

3. **多帧优化：**
   - 时间相干性利用
   - 增量更新加速结构

**结论**

对于静态模型的多帧渲染，预处理成本被摊销到多帧中，使得后续帧的渲染效率显著提高。这种分析对于实时光线追踪和离线渲染的性能预测都具有重要价值。
